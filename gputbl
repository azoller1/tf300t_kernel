diff --git a/arch/arm/mach-tegra/common.c b/arch/arm/mach-tegra/common.c
index 516a74b..76287dd 100644
--- a/arch/arm/mach-tegra/common.c
+++ b/arch/arm/mach-tegra/common.c
@@ -104,7 +104,8 @@ static struct board_info pmu_board_info;
 static struct board_info display_board_info;
 static struct board_info camera_board_info;
 
-static int pmu_core_edp = 1300;	/* default 1.2V EDP limit */
+/* default EDP limit is 1.2V */
+static int pmu_core_edp = 1600;	/* default 1.6V EDP limit */
 static int board_panel_type;
 static enum power_supply_type pow_supply_type = POWER_SUPPLY_TYPE_MAINS;
 
diff --git a/arch/arm/mach-tegra/dvfs.c b/arch/arm/mach-tegra/dvfs.c
index c36b81d..8ef78e4 100644
--- a/arch/arm/mach-tegra/dvfs.c
+++ b/arch/arm/mach-tegra/dvfs.c
@@ -343,11 +343,14 @@ __tegra_dvfs_set_rate(struct dvfs *d, unsigned long rate)
 	if (freqs == NULL || d->millivolts == NULL)
 		return -ENODEV;
 
+/* disabled for the GPU custom clocks interface */
+#if 0
 	if (rate > freqs[d->num_freqs - 1]) {
 		pr_warn("tegra_dvfs: rate %lu too high for dvfs on %s\n", rate,
 			d->clk_name);
 		return -EINVAL;
 	}
+#endif
 
 	if (rate == 0) {
 		d->cur_millivolts = 0;
@@ -355,12 +358,16 @@ __tegra_dvfs_set_rate(struct dvfs *d, unsigned long rate)
 		while (i < d->num_freqs && rate > freqs[i])
 			i++;
 
+/* disabled for the GPU custom clocks interface */
+#if 0
 		if ((d->max_millivolts) &&
 		    (d->millivolts[i] > d->max_millivolts)) {
 			pr_warn("tegra_dvfs: voltage %d too high for dvfs on"
 				" %s\n", d->millivolts[i], d->clk_name);
 			return -EINVAL;
 		}
+#endif
+
 		d->cur_millivolts = d->millivolts[i];
 	}
 
diff --git a/arch/arm/mach-tegra/dvfs.h b/arch/arm/mach-tegra/dvfs.h
index 15119f7..d2b3320 100644
--- a/arch/arm/mach-tegra/dvfs.h
+++ b/arch/arm/mach-tegra/dvfs.h
@@ -24,6 +24,8 @@
 #define MAX_DVFS_FREQS	40
 #define DVFS_RAIL_STATS_TOP_BIN	42
 
+#include "clock.h"
+
 struct clk;
 struct dvfs_rail;
 
@@ -83,7 +85,7 @@ struct dvfs {
 	int freqs_mult;
 	unsigned long freqs[MAX_DVFS_FREQS];
 	unsigned long *alt_freqs;
-	const int *millivolts;
+	unsigned int *millivolts;
 	struct dvfs_rail *dvfs_rail;
 	bool auto_dvfs;
 
diff --git a/arch/arm/mach-tegra/tegra3_clocks.c b/arch/arm/mach-tegra/tegra3_clocks.c
index 4c27601..730eb2b 100644
--- a/arch/arm/mach-tegra/tegra3_clocks.c
+++ b/arch/arm/mach-tegra/tegra3_clocks.c
@@ -3062,11 +3062,15 @@ static noinline int shared_bus_set_rate(struct clk *bus, unsigned long rate,
 
 	mv = tegra_dvfs_predict_millivolts(bus, rate);
 	old_mv = tegra_dvfs_predict_millivolts(bus, old_rate);
+
+/* disabled for the GPU custom clocks interface */
+#if 0
 	if (IS_ERR_VALUE(mv) || IS_ERR_VALUE(old_mv)) {
 		pr_err("%s: Failed to predict %s voltage for %lu => %lu\n",
 		       __func__, bus->name, old_rate, rate);
 		return -EINVAL;
 	}
+#endif
 
 	/* emc bus: set bridge rate as intermediate step when crossing
 	 * bridge threshold in any direction
@@ -3335,6 +3339,18 @@ static struct clk tegra_pll_ref = {
 };
 
 static struct clk_pll_freq_table tegra_pll_c_freq_table[] = {
+	{ 12000000, 1500000000, 750,  6, 1, 8},
+	{ 13000000, 1500000000, 750, 13, 2, 8},
+	{ 16800000, 1500000000, 625,  7, 1, 8},
+	{ 19200000, 1500000000, 625,  8, 1, 8},
+	{ 26000000, 1500000000, 750, 13, 1, 8},
+
+	{ 12000000, 1332000000, 666,  6, 1, 8},
+	{ 13000000, 1332000000, 666, 13, 2, 8},    /* actual: 1199.9 MHz */
+	{ 16800000, 1332000000, 555,  7, 1, 8},
+	{ 19200000, 1332000000, 555,  8, 1, 8},
+	{ 26000000, 1332000000, 666, 13, 1, 8},
+
 	{ 12000000, 1200000000, 600,  6, 1, 8},
 	{ 13000000, 1200000000, 923, 10, 1, 8},		/* actual: 1199.9 MHz */
 	{ 16800000, 1200000000, 500,  7, 1, 8},
@@ -3385,7 +3401,7 @@ static struct clk tegra_pll_c = {
 	.ops       = &tegra_pll_ops,
 	.reg       = 0x80,
 	.parent    = &tegra_pll_ref,
-	.max_rate  = 1400000000,
+	.max_rate  = 1600000000,
 	.u.pll = {
 		.input_min = 2000000,
 		.input_max = 31000000,
@@ -3405,7 +3421,7 @@ static struct clk tegra_pll_c_out1 = {
 	.parent    = &tegra_pll_c,
 	.reg       = 0x84,
 	.reg_shift = 0,
-	.max_rate  = 700000000,
+	.max_rate  = 800000000,
 };
 
 static struct clk_pll_freq_table tegra_pll_m_freq_table[] = {
diff --git a/arch/arm/mach-tegra/tegra3_dvfs.c b/arch/arm/mach-tegra/tegra3_dvfs.c
index 2e68385..324ccbc 100644
--- a/arch/arm/mach-tegra/tegra3_dvfs.c
+++ b/arch/arm/mach-tegra/tegra3_dvfs.c
@@ -59,7 +59,7 @@ static int cpu_below_core = VDD_CPU_BELOW_VDD_CORE;
 
 static struct dvfs_rail tegra3_dvfs_rail_vdd_cpu = {
 	.reg_id = "vdd_cpu",
-	.max_millivolts = 1250,
+	.max_millivolts = 1600,
 	.min_millivolts = 725,
 	.step = VDD_SAFE_STEP,
 	.jmp_to_zero = true,
@@ -67,7 +67,7 @@ static struct dvfs_rail tegra3_dvfs_rail_vdd_cpu = {
 
 static struct dvfs_rail tegra3_dvfs_rail_vdd_core = {
 	.reg_id = "vdd_core",
-	.max_millivolts = 1350,
+	.max_millivolts = 1600,
 	.min_millivolts = 950,
 	.step = VDD_SAFE_STEP,
 };
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 26faaa2..6920dca 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -31,6 +31,8 @@
 #include <linux/syscore_ops.h>
 #include <linux/pm_qos_params.h>
 
+#include "../../arch/arm/mach-tegra/dvfs.h"
+
 #include <trace/events/power.h>
 
 /**
@@ -596,6 +598,85 @@ static ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)
 	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
 }
 
+static ssize_t show_gpu_oc(struct cpufreq_policy *policy, char *buf)
+{
+	struct clk *gpu = tegra_get_clock_by_name("3d");
+        
+	return sprintf(buf, "%lu\n", gpu->dvfs->freqs[7]/1000000);
+}
+
+static ssize_t store_gpu_oc(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	int ret, i;
+	unsigned long gpu_freq = 0;
+	unsigned long new_gpu_freq = 0;
+	unsigned int new_volt = 0;
+        
+	//all the clocks that need to be updated with the new frequencies
+	struct clk *vde = tegra_get_clock_by_name("vde");
+	struct clk *mpe = tegra_get_clock_by_name("mpe");
+	struct clk *two_d = tegra_get_clock_by_name("2d");
+	struct clk *epp = tegra_get_clock_by_name("epp");
+	struct clk *three_d = tegra_get_clock_by_name("3d");
+	struct clk *three_d2 = tegra_get_clock_by_name("3d2");
+	struct clk *se = tegra_get_clock_by_name("se");
+	struct clk *cbus = tegra_get_clock_by_name("cbus");
+	struct clk *host1x = tegra_get_clock_by_name("host1x");
+	struct clk *pll_c = tegra_get_clock_by_name("pll_c");
+
+	ret = sscanf(buf, "%lu", &gpu_freq);
+
+	if (!ret)
+		return -EINVAL;
+
+	new_gpu_freq = gpu_freq*1000000;
+
+	vde->max_rate = new_gpu_freq;
+	mpe->max_rate = new_gpu_freq;
+	two_d->max_rate = new_gpu_freq;
+	epp->max_rate = new_gpu_freq;
+	three_d->max_rate = new_gpu_freq;
+	three_d2->max_rate = new_gpu_freq;
+	se->max_rate = new_gpu_freq;
+	host1x->max_rate = DIV_ROUND_UP((new_gpu_freq),2);
+	cbus->max_rate = new_gpu_freq;
+	pll_c->max_rate = (new_gpu_freq*2);
+
+	i = vde->dvfs->num_freqs;
+
+	for (i--; i >= 5; i--) 
+	{
+		if (gpu_freq < 600) 
+		{
+			new_volt = 1250;
+			vde->dvfs->millivolts[i] = new_volt;
+		}                        
+
+		if (gpu_freq >= 600 && gpu_freq < 700) 
+		{
+			new_volt = 1400;
+			vde->dvfs->millivolts[i] = new_volt;
+		}
+
+		if (gpu_freq >= 700) {
+			new_volt = 1550;
+			vde->dvfs->millivolts[i] = new_volt;
+		}
+
+		vde->dvfs->freqs[i] = new_gpu_freq;
+		mpe->dvfs->freqs[i] = new_gpu_freq;
+		two_d->dvfs->freqs[i] = new_gpu_freq;
+		epp->dvfs->freqs[i] = new_gpu_freq;
+		three_d->dvfs->freqs[i] = new_gpu_freq;
+		three_d2->dvfs->freqs[i] = new_gpu_freq;
+		se->dvfs->freqs[i] = new_gpu_freq;
+		cbus->dvfs->freqs[i] = new_gpu_freq;
+		pll_c->dvfs->freqs[i] = (new_gpu_freq*2);
+	}
+
+	return count;
+}
+
 cpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);
 cpufreq_freq_attr_ro(cpuinfo_min_freq);
 cpufreq_freq_attr_ro(cpuinfo_max_freq);
@@ -613,6 +694,7 @@ cpufreq_freq_attr_rw(scaling_setspeed);
 cpufreq_freq_attr_ro(policy_min_freq);
 cpufreq_freq_attr_ro(policy_max_freq);
 cpufreq_freq_attr_rw(dvfs_test);
+cpufreq_freq_attr_rw(gpu_oc);
 
 static struct attribute *default_attrs[] = {
 	&cpuinfo_min_freq.attr,
@@ -629,6 +711,7 @@ static struct attribute *default_attrs[] = {
 	&policy_min_freq.attr,
 	&policy_max_freq.attr,
 	&dvfs_test.attr,
+	&gpu_oc.attr,
 	NULL
 };
 
diff --git a/drivers/video/tegra/host/nvhost_acm.c b/drivers/video/tegra/host/nvhost_acm.c
index 7d464c5..fba8d0e 100644
--- a/drivers/video/tegra/host/nvhost_acm.c
+++ b/drivers/video/tegra/host/nvhost_acm.c
@@ -141,14 +141,18 @@ static void to_state_running_locked(struct nvhost_device *dev)
 		if (dev->dev.parent)
 			nvhost_module_busy(to_nvhost_device(dev->dev.parent));
 
-		for (i = 0; i < dev->num_clks; i++) {
-			int err = clk_enable(dev->clk[i]);
+		for (i = 0; i < dev->num_clks; i++)
+			clk_enable(dev->clk[i]);
+
+/* disabled for the GPU custom clocks interface */
+#if 0
 			if (err) {
 				dev_err(&dev->dev, "Cannot turn on clock %s",
 					dev->clocks[i].name);
 				return;
 			}
 		}
+#endif
 
 		/* Invoke callback after enabling clock. This is used for
 		 * re-enabling host1x interrupts. */
